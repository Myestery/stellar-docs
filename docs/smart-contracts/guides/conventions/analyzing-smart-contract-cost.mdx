---
title: Analyzing smart contract cost
hide_table_of_contents: false
---

Several factors influence how quickly and efficiently your smart contracts execute on the Stellar network. This guide will help you understand these factors and provide tips on how to write cost-effective contracts.

# **How to optimize smart contract cost**:

Complex contracts with numerous conditions, loops, and computations require more processing power on Stellar. This can lead to higher gas costs (transaction fees) and slower execution times.

### 1. **Efficient loop and storage calls usage**

A contract that requires multiple loops and conditions to execute will cost more than a simple contract that executes a single operation.

#### Not Optimal Contract ❎

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, log, vec,Map, Env};

#[contract]
pub struct ExampleContract;

#[contractimpl]
impl ExampleContract {
    // Function to update values in storage inefficiently
    pub fn update_values(env: Env, values: Vec<u32>) {
        for &value in values.iter() {
            let current_count = env.storage().persistent().get("total_count");
            env.storage().persistent().set("total_count", &(current_count + value));
        }
    }
}

```

:::danger

_Problem_ : Each iteration of the loop performs a separate read and write operation to update total_count in storage.

_Inefficient_: This results in multiple expensive storage operations (read and write) within the loop, increasing gas costs significantly as the array size (values.len()) grows.

:::

#### Optimal Contract ✅

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, log, vec, Env, Map};

#[contract]
pub struct ExampleContract;

#[contractimpl]
impl ExampleContract {
    // Function to update values in storage efficiently
    pub fn update_values(env: Env, values: Vec<u32>) {
        let mut total_count = env.storage().persistent().get("total_count");

        for &value in values.iter() {
            total_count += value;
        }

        env.storage().persistent().set("total_count", &total_count);
    }
}

```

:::tip In this optimized approach, we'll accumulate the changes outside the loop and perform a single storage update and also a single read operation. This reduces the number of storage operations and the overall gas cost of the contract. :::

### 2. **Use of Events over Storage**

Events are a cost-effective way to store data that doesn't need to be accessed frequently. Events are cheaper than storage operations and can be used to store data that doesn't need to be accessed frequently.

#### Not Optimal Contract ❎

```rust
#![no_std]
use soroban_sdk::{
    contract, contractimpl, log, symbol_short, vec, Address, Env, Symbol,Map, Vec
};

#[contract]
pub struct GameContract;

#[contractimpl]
impl GameContract {
    // Function to record a game move and update storage
    pub fn record_move(env: Env, player: Address, move_type: Symbol) {
        let mut player_moves: Map<Address, Vec<Symbol>> = env.storage().persistent().get("player_moves");
        let moves = player_moves.get(&player);
        moves.push(move_type.clone());
        player_moves.set(player, moves);
        env.storage().persistent().set("player_moves", &player_moves);
    }

    // Function to unlock an achievement and update storage
    pub fn unlock_achievement(env: Env, player: Address, achievement: Symbol) {
        let mut player_achievements: Map<Address, Vec<Symbol>> = env.storage().persistent().get("player_achievements");
        let achievements = player_achievements.get(&player);
        achievements.push(achievement.clone());
        player_achievements.set(player, achievements);
        env.storage().persistent().set("player_achievements", &player_achievements);
    }

}
```

:::danger We cannot store everything in storage like we would do in a traditional database. This approach is not cost-effective as it involves multiple storage operations for each player move and saves each achievement to the storage :::

#### Optimal Contract ✅

```rust
#![no_std]
use soroban_sdk::{
    contract, contractimpl, log, symbol_short, vec, Address, Env, Symbol,Map, Vec,
};

#[contract]
pub struct GameContract;

#[contractimpl]
impl GameContract {
    // Function to record a game move and emit an event
    pub fn record_move(env: Env, player: Address, move_type: Symbol) {
        // Emit event for the game move
        env.events().publish(("game_move",), (&player, move_type.clone()));
    }

    // Function to unlock an achievement and emit an event
    pub fn unlock_achievement(env: Env, player: Address, achievement: Symbol) {
        // Emit event for the unlocked achievement
        env.events().publish(("achievement_unlocked",), (&player, achievement.clone()));
    }
}
```

:::tip In this optimized approach, we'll use events to store data that doesn't need to be accessed frequently. This reduces the number of storage operations and the overall gas cost of the contract. :::

### 3. **Use of Efficient Data Structures**

Heap allocated arrays are slow and costly. Prefer fixed-sized arrays or `soroban_sdk::vec!`. This is crucial for large arrays, as exceeding the current linear memory size (a multiple of 64KB) triggers `wasm32::memory_grow`, which is highly computationally intensive.

##### Example (Heap Allocated Array) ❎

```rust
let mut v1 = alloc::vec![];
```

##### Example (Fixed-Sized Array) ✅

```rust
let mut v2 = [0; 100];
```

Maps help a lot to prevent multiple storage operations. Use `soroban_sdk::Map` for efficient storage operations.

##### Example (Inefficient Data Storage) ❎

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, log, vec, Address, Env, Symbol, Vec};

#[contract]
pub struct ExampleContract;

#[contractimpl]
impl ExampleContract {
    // Function to add an item to the collection
    pub fn add_item(env: Env, item: Symbol) {
        let mut items: Vec<Symbol> = env.storage().persistent().get("items");
        if !items.contains(&item) {
            items.push(item.clone());
            env.storage().persistent().set("items", &items);
            log!(&env, "Item added: {}", item);
        } else {
            log!(&env, "Item already exists: {}", item);
        }
    }

    // Function to check if an item exists in the collection
    pub fn contains_item(env: Env, item: Symbol) -> bool {
        let items: Vec<Symbol> = env.storage().persistent().get("items");
        let exists = items.contains(&item);
        log!(&env, "Item exists: {}", exists);
        exists
    }
}
```

:::danger

- Data Structure: Uses a Vec to store items.
- Inefficiency: Membership checks (contains) have linear time complexity O(n), making the contract inefficient for large collections.
- Storage Operations: Involves multiple storage operations for each item addition and retrieval, increasing gas costs. :::

##### Example (Correct Data Storage) ✅

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, log, Address, Env, Map, Symbol};

#[contract]
pub struct ExampleContract;

#[contractimpl]
impl ExampleContract {
    // Function to add an item to the collection
    pub fn add_item(env: Env, item: Symbol) {
        let mut items: Map<Symbol, ()> = env.storage().persistent().get_or_default("items");
        if !items.contains_key(&item) {
            items.set(item.clone(), ());
            env.storage().persistent().set("items", &items);
            log!(&env, "Item added: {}", item);
        } else {
            log!(&env, "Item already exists: {}", item);
        }
    }

    // Function to check if an item exists in the collection
    pub fn contains_item(env: Env, item: Symbol) -> bool {
        let items: Map<Symbol, ()> = env.storage().persistent().get_or_default("items");
        let exists = items.contains_key(&item);
        log!(&env, "Item exists: {}", exists);
        exists
    }
}
```

:::tip

- Data Structure: Uses a Map to store items.
- Efficiency: Membership checks (contains) have constant time complexity O(1), making the contract efficient for large collections.
- Storage Operations: Minimizes storage operations by using a single Map for item storage, reducing gas costs. :::

### 4. **Contract size**

The size of your smart contract's `wasm` binary influences the cost of running your smart contract on the Stellar network. Larger `wasm` binaries require more processing power and memory to execute, leading to higher gas costs. Larger binaries also cost more gas to deploy and invoke.

To optimize the size of your `wasm` binary, you can:

- Remove unnecessary code
- Minimize the use of external dependencies
- Use built-in tools to optimize the size of your `wasm` binary

#### Example (Non-Optimized Contract) ❎

```rust
#![no_std]

extern crate serde;
extern crate serde_json;
extern crate regex;

use soroban_sdk::{contract, contractimpl, log, vec, Env, Symbol};
use serde::{Deserialize, Serialize};
use regex::Regex;

#[contract]
pub struct ExampleContract;

#[contractimpl]
impl ExampleContract {
    // Function to log a message
    pub fn log_message(env: Env, message: Symbol) {
        log!(&env, "Message: {}", message);

        // Unnecessary use of serde and regex
        let _data: Vec<u8> = serde_json::to_vec(&message).unwrap();
        let _re = Regex::new(r"\w+").unwrap();
    }
}
```

:::danger

- Unnecessary Libraries: The contract includes serde, serde_json, and regex, which are not essential for the contract's primary functionality.
- Increased WASM Size: Including these libraries adds unnecessary bloat, increasing the size of the compiled WASM file :::

#### Example (Optimized Contract) ✅

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, log, Env, Symbol};

#[contract]
pub struct ExampleContract;

#[contractimpl]
impl ExampleContract {
    // Function to log a message
    pub fn log_message(env: Env, message: Symbol) {
        log!(&env, "Message: {}", message);
    }
}
```

:::tip

- Essential Libraries Only: The contract only includes soroban_sdk, which is necessary for its functionality.
- Reduced WASM Size: By avoiding unnecessary libraries, the size of the compiled WASM file is minimized. :::

## Other tips to optimize smart contract cost:

### 1. **Use of built-in tools**

One way to optimize the size of your `wasm` binary is to use the `soroban optimize` command. This command comes from the [Soroban CLI](https://www.google.com) will optimize the size of your `wasm` binary by removing unnecessary code and reducing the size of the binary.

```bash
soroban optimize \
  --wasm target/wasm32-unknown-unknown/release/project.wasm
```

Another way to optimize your smart contract is to use the `soroban invoke` command with the `--footprint` flag. This command will provide you with a detailed breakdown of the cost of running your smart contract on the Stellar network.

```bash
soroban invoke \
  --wasm target/wasm32-unknown-unknown/release/project.wasm \
  --id 1 \
  --fn add \
  --arg 1 \
  --arg 2 \
  --cost \
  --footprint
```

Reference: https://sorobandev.com/guides/soroban-cli

### 2. **Manual code review**

Perform a manual code review of your smart contract to identify areas where you can optimize the code. Look for redundant loops, conditions, and storage operations that can be minimized or removed.

### 3. **Unit testing with gas measurements:**

Use unit tests to measure the gas cost of your smart contract functions. This will help you identify functions that are consuming a lot of gas and optimize them accordingly.

Frameworks like `cargo-contract` provide tools to measure the gas cost of your smart contract functions. Use these tools to identify bottlenecks in your smart contract code.

### 4. **Static analysis tools:**

Tools like [Clippy](https://doc.rust-lang.org/clippy/) (part of the Rust compiler) can identify potential performance issues during the compilation stage. These tools can warn about:

- Unnecessary allocations
- Redundant code

### 5. **Reconsidering Storage Mechanisms**

- #### State Variables:

  - Cost: State variables are stored directly on the blockchain's storage. The cost is primarily influenced by the amount of data stored (measured in bytes) and the frequency of read and write operations.
  - Considerations: Writing data to state variables typically incurs higher gas costs compared to reading data. Complex data structures (e.g., arrays, mappings) or large amounts of data increase storage costs and gas consumption. Stellar charges gas fees for each byte of data stored and updated, making efficient data management crucial for cost optimization.

- #### Event Logs:

  - Cost: Emitting events in Rust contracts does not incur direct storage costs since events are not permanently stored on the blockchain. Instead, they are included in transaction logs.
  - Considerations: Emitting events consumes gas, primarily due to the computational resources required to execute event emission and log generation. Events are useful for off-chain applications and event-driven architectures but do not contribute directly to on-chain storage costs.

- #### External Data Sources:

  - Cost: Interacting with external data sources like oracles involves transaction fees for data retrieval and processing.
  - Considerations: Oracle calls incur gas costs for contract execution, which can vary depending on the complexity and frequency of data fetching. Contract developers should consider gas limits and optimize oracle interactions to minimize costs while ensuring reliable data integration.

- #### Immutable Data and Constants:

  - Cost: Constants and immutable variables incur negligible storage costs since they are typically stored as part of the contract's bytecode or metadata.
  - Considerations: Constants and immutable data are crucial for contract configuration and parameterization but do not impact transaction or storage costs significantly. They are pre-defined during contract deployment and do not change during contract execution, avoiding additional gas costs for storage updates.

- #### Off-Chain Storage and IPFS:
  - Cost: Storing data off-chain using solutions like IPFS avoids direct on-chain storage costs but incurs costs for data retrieval and IPFS network usage.
  - Considerations: Contracts store only the hash or reference to off-chain data on-chain, minimizing on-chain storage costs. Gas costs may apply when retrieving and processing off-chain data, depending on the complexity and frequency of access. Off-chain storage solutions offer scalability and flexibility but require careful consideration of network fees and data availability.
