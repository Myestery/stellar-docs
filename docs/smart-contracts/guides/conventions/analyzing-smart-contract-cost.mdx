---
title: Analyzing Smart Contract Cost
hide_table_of_contents: false
---

When writing smart contracts on the Soroban network, it is important to consider several factors which influence how efficiently and quickly your Soroban smart contracts execute. These factors translate into the cost of running your smart contract on the network. This guide will help you understand the factors that influence the cost of running your smart contract on the Soroban network.

## Factors influencing smart contract cost

### 1. **Contract Complexity**

Complex contracts with numerous conditions, loops, and computations require more processing power on Soroban. This can lead to higher gas costs (transaction fees) and slower execution times.

#### Example (Complex vs. Simple Contract)

A contract that requires multiple loops and conditions to execute will cost more than a simple contract that executes a single operation.

##### Complex Contract ❎

```rust
#[contractimpl]
pub fn complex_transfer(ctx: Context, from: AccountAddress, to: AccountAddress, amount: u64) -> Result<(), ContractError> {
  // Multiple conditions and calculations for eligibility checks
  if is_account_verified(ctx, from)? && has_sufficient_balance(ctx, from, amount)? {
      // Perform multiple transfers with complex logic
      for i in 0..10 {
          let intermediate_account = AccountAddress::from_str("...");
          transfer(ctx, from, intermediate_account, amount / 2)?;
          transfer(ctx, intermediate_account, to, amount / 2)?;
      }
  } else {
      Err(ContractError::InsufficientFunds)
  }
  Ok(())
}
```

##### Simple Contract ✅

```rust
#[contractimpl]
pub fn simple_transfer(ctx: Context, from: AccountAddress, to: AccountAddress, amount: u64) -> Result<(), ContractError> {
  // Single check for balance
  if has_sufficient_balance(ctx, from, amount)? {
      transfer(ctx, from, to, amount)?;
  } else {
      Err(ContractError::InsufficientFunds)
  }
  Ok(())
}
```

### 2. **Storage Operations**

Storage operations in smart contracts are expensive. Each read or write operation to the storage incurs a cost. Minimize the number of storage operations in your smart contract to reduce costs.

Heap allocated arrays are slow and costly. Prefer fixed-sized arrays or `soroban_sdk::vec!`. This is crucial for large arrays, as exceeding the current linear memory size (a multiple of 64KB) triggers `wasm32::memory_grow`, which is highly computationally intensive.

##### Example (Heap Allocated Array) ❎

```rust
let mut v1 = alloc::vec![];
```

##### Example (Fixed-Sized Array) ✅

```rust
let mut v2 = [0; 100];
```

##### Events vs Storage

Use events to store data that does not need to be accessed frequently. This reduces the number of storage operations and the cost of running your smart contract.

## How to optimize smart contract cost

### 1. **Use of In-Built Tools**

One way to optimize the size of your `wasm` binary is to use the `soroban optimize` command. This command comes from the [Soroban CLI](https://www.google.com) will optimize the size of your `wasm` binary by removing unnecessary code and reducing the size of the binary.

```bash
soroban optimize \
  --wasm target/wasm32-unknown-unknown/release/project.wasm
```

Another way to optimize your smart contract is to use the `soroban invoke` command with the `--footprint` flag. This command will provide you with a detailed breakdown of the cost of running your smart contract on the Soroban network.

```bash
soroban invoke \
  --wasm target/wasm32-unknown-unknown/release/project.wasm \
  --id 1 \
  --fn add \
  --arg 1 \
  --arg 2 \
  --cost \
  --footprint
```

reference: https://sorobandev.com/guides/soroban-cli

### 2. **Manual Code Review**

Perform a manual code review of your smart contract to identify areas where you can optimize the code. Look for redundant loops, conditions, and storage operations that can be minimized or removed.

### 3. **Unit Testing with Gas Measurements:**

Use unit tests to measure the gas cost of your smart contract functions. This will help you identify functions that are consuming a lot of gas and optimize them accordingly.

Frameworks like `cargo-contract` provide tools to measure the gas cost of your smart contract functions. Use these tools to identify bottlenecks in your smart contract code.

### 4. **Static Analysis Tools:**

Tools like [Clippy](https://doc.rust-lang.org/clippy/) (part of the Rust compiler) can identify potential performance issues during the compilation stage. These tools can warn about:

- Unnecessary allocations
- Redundant code

### 5. **Blockchain Explorers:**

Once deployed, blockchain explorers can provide insights into actual gas consumption of your contract transactions. Analyze historical data to identify trends and optimize accordingly.
