---
title: Comprehensive Frontend Guide for Stellar Dapps
description: Learn how to build functional frontend interfaces for Stellar dapps using React, Tailwind CSS, and the Stellar SDK.
---

# Comprehensive Frontend Guide for Stellar Dapps

### Pre-Requisites:

- Basic Knowledge of React, Tailwind CSS and related web technologies
- Basic Understanding of Stellar Blockchain
- Node.js and npm Installed

## 1. Introduction

### The Role of Frontend in Stellar Dapps

Frontend development plays a crucial role in decentralized applications (dapps) built on the Stellar network. It serves as the primary interface between users and the underlying blockchain technology. A well-designed frontend not only makes your dapp accessible and user-friendly but also helps users interact with complex blockchain operations seamlessly.

In Stellar dapps, the frontend is responsible for:

1. Presenting blockchain data in a human-readable format
2. Facilitating user interactions with smart contracts and Stellar operations
3. Managing user accounts and keys securely
4. Providing real-time updates on transaction status and account balances
5. Guiding users through complex processes like multi-signature transactions or claimable balance operations

### Importance of User Interface and User Experience

The importance of a good user interface (UI) and user experience (UX) in Stellar dapps cannot be overstated. Blockchain technology can be intimidating for many users, and a well-designed UI/UX can make the difference between a successful dapp and one that users find frustrating or confusing.

Key aspects of UI/UX in Stellar dapps include:

1. Simplicity: Presenting complex blockchain concepts in an easy-to-understand manner
2. Transparency: Providing clear information about transaction fees, network status, and operation outcomes
3. Feedback: Offering immediate and clear feedback on user actions and transaction progress
4. Error Handling: Gracefully managing and explaining errors in a user-friendly way
5. Performance: Ensuring quick load times and responsive interactions, even when dealing with blockchain operations

By focusing on these aspects, you can create Stellar dapps that are not only functional but also enjoyable to use, encouraging wider adoption of your application and the Stellar network as a whole.

## 2. Setting Up the Development Environment

Before we start building our Stellar dapp, we need to set up our development environment. We'll be using React with Next.js for our frontend framework, Tailwind CSS for styling, and the Stellar SDK for interacting with the Stellar network.

### Installing Node.js and npm

First, make sure you have Node.js and npm (Node Package Manager) installed on your system. You can download and install them from the official Node.js website: https://nodejs.org/

To verify your installation, open a terminal and run:

```bash
node --version
npm --version
```

Both commands should return version numbers if the installation was successful.

### Setting Up a Next.js Project

Next.js is a React framework that provides features such as server-side rendering and routing out of the box. To create a new Next.js project, run the following commands in your terminal:

```bash
npx create-next-app@latest stellar-dapp
cd stellar-dapp
```

When prompted, choose the following options:

- Would you like to use TypeScript? Yes
- Would you like to use ESLint? Yes
- Would you like to use Tailwind CSS? Yes
- Would you like to use `src/` directory? Yes
- Would you like to use App Router? Yes
- Would you like to customize the default import alias? No

### Installing and Configuring Tailwind CSS

Tailwind CSS should already be installed and configured if you selected it during the Next.js project creation. If you need to manually install it, you can follow these steps:

1. Install Tailwind CSS and its peer dependencies:

```bash
npm install -D tailwindcss postcss autoprefixer
```

2. Generate Tailwind CSS configuration files:

```bash
npx tailwindcss init -p
```

3. Update the `tailwind.config.js` file to include the paths to your template files:

```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

4. Add the Tailwind directives to your `src/app/globals.css` file:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

### Installing Stellar SDK and Other Dependencies

To interact with the Stellar network, we'll need to install the Stellar SDK and some additional dependencies:

```bash
npm install stellar-sdk @stellar/freighter-api bignumber.js
```

- `stellar-sdk`: The official Stellar SDK for interacting with the Stellar network
- `@stellar/freighter-api`: A library for integrating with the Freighter wallet (a popular Stellar wallet browser extension)
- `bignumber.js`: A library for arbitrary-precision decimal and non-decimal arithmetic

Now that we have our development environment set up, we're ready to start building our Stellar dapp!

## 3. Building Basic Interface Elements

In this section, we'll create reusable components for our Stellar dapp and implement forms and inputs using React and Tailwind CSS.

### Creating Reusable Components

Let's start by creating a button component that we'll use throughout our application. Create a new file `src/components/Button.tsx`:

```typescript
import React from 'react';

interface ButtonProps {
  onClick: () => void;
  children: React.ReactNode;
  disabled?: boolean;
  className?: string;
}

const Button: React.FC<ButtonProps> = ({ onClick, children, disabled = false, className = '' }) => {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`px-4 py-2 font-bold text-white bg-blue-500 rounded hover:bg-blue-700 focus:outline-none focus:shadow-outline ${
        disabled ? 'opacity-50 cursor-not-allowed' : ''
      } ${className}`}
    >
      {children}
    </button>
  );
};

export default Button;
```

This button component uses Tailwind CSS classes for styling and accepts props for customization.

### Implementing Forms and Inputs

Next, let's create a reusable input component. Create a new file `src/components/Input.tsx`:

```typescript
import React from 'react';

interface InputProps {
  type: string;
  placeholder: string;
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  className?: string;
}

const Input: React.FC<InputProps> = ({ type, placeholder, value, onChange, className = '' }) => {
  return (
    <input
      type={type}
      placeholder={placeholder}
      value={value}
      onChange={onChange}
      className={`shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline ${className}`}
    />
  );
};

export default Input;
```

Now, let's create a form component that uses these reusable components. Create a new file `src/components/SendPaymentForm.tsx`:

```typescript
import React, { useState } from 'react';
import Button from './Button';
import Input from './Input';

interface SendPaymentFormProps {
  onSubmit: (destination: string, amount: string) => void;
}

const SendPaymentForm: React.FC<SendPaymentFormProps> = ({ onSubmit }) => {
  const [destination, setDestination] = useState('');
  const [amount, setAmount] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSubmit(destination, amount);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="destination" className="block text-sm font-medium text-gray-700">
          Destination Address
        </label>
        <Input
          type="text"
          placeholder="GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
          value={destination}
          onChange={(e) => setDestination(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="amount" className="block text-sm font-medium text-gray-700">
          Amount (XLM)
        </label>
        <Input
          type="text"
          placeholder="0.0"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
        />
      </div>
      <Button onClick={handleSubmit} disabled={!destination || !amount}>
        Send Payment
      </Button>
    </form>
  );
};

export default SendPaymentForm;
```

### Designing Responsive Layouts with Tailwind CSS

To create a responsive layout for our dapp, we'll use Tailwind CSS utility classes. Let's create a layout component that we can use across our pages. Create a new file `src/components/Layout.tsx`:

```typescript
import React from 'react';

interface LayoutProps {
  children: React.ReactNode;
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  return (
    <div className="min-h-screen bg-gray-100">
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8">
          <h1 className="text-3xl font-bold text-gray-900">Stellar Dapp</h1>
        </div>
      </header>
      <main>
        <div className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
          <div className="px-4 py-6 sm:px-0">
            <div className="border-4 border-dashed border-gray-200 rounded-lg h-96">
              {children}
            </div>
          </div>
        </div>
      </main>
    </div>
  );
};

export default Layout;
```

Now, let's update our `src/app/page.tsx` file to use this layout and our new components:

```typescript
import React from 'react';
import Layout from '../components/Layout';
import SendPaymentForm from '../components/SendPaymentForm';

export default function Home() {
  const handleSendPayment = (destination: string, amount: string) => {
    // We'll implement this function in the next section
    console.log(`Sending ${amount} XLM to ${destination}`);
  };

  return (
    <Layout>
      <div className="max-w-md mx-auto">
        <h2 className="text-2xl font-bold mb-4">Send Payment</h2>
        <SendPaymentForm onSubmit={handleSendPayment} />
      </div>
    </Layout>
  );
}
```

This setup provides a solid foundation for building the user interface of our Stellar dapp. In the next section, we'll integrate these components with the Stellar SDK to perform actual blockchain operations.

## 4. Integrating with Stellar Blockchain

Now that we have our basic UI components in place, let's integrate them with the Stellar blockchain using the Stellar SDK.

### Setting Up Stellar SDK

First, let's create a utility file to set up and export our Stellar SDK instance. Create a new file `src/utils/stellar.ts`:

```typescript
import { Horizon, Networks, Server } from "stellar-sdk";

// Use the testnet for development
const NETWORK_URL = "https://horizon-testnet.stellar.org";
const NETWORK_PASSPHRASE = Networks.TESTNET;

export const server = new Server(NETWORK_URL);

export { Networks, Horizon };
export const getNetworkPassphrase = () => NETWORK_PASSPHRASE;
```

### Connecting to Stellar Network

Now, let's create a custom hook to manage our connection to the Stellar network and handle account creation. Create a new file `src/hooks/useStellar.ts`:

```typescript
import { useState, useCallback } from "react";
import { Keypair, Account } from "stellar-sdk";
import { server, getNetworkPassphrase } from "../utils/stellar";

export const useStellar = () => {
  const [account, setAccount] = useState<Account | null>(null);
  const [publicKey, setPublicKey] = useState<string | null>(null);
  const [secretKey, setSecretKey] = useState<string | null>(null);

  const createAccount = useCallback(async () => {
    try {
      const pair = Keypair.random();
      const accountId = pair.publicKey();

      // Fund the account using Friendbot (only works on testnet)
      await fetch(
        `https://friendbot.stellar.org?addr=${encodeURIComponent(accountId)}`,
      );

      const account = await server.loadAccount(accountId);
      setAccount(account);
      setPublicKey(pair.publicKey());
      setSecretKey(pair.secret());
    } catch (error) {
      console.error("Error creating account:", error);
    }
  }, []);

  const signIn = useCallback(async (secretKey: string) => {
    try {
      const keypair = Keypair.fromSecret(secretKey);
      const account = await server.loadAccount(keypair.publicKey());
      setAccount(account);
      setPublicKey(keypair.publicKey());
      setSecretKey(secretKey);
    } catch (error) {
      console.error("Error signing in:", error);
    }
  }, []);

  const signOut = useCallback(() => {
    setAccount(null);
    setPublicKey(null);
    setSecretKey(null);
  }, []);

  return {
    account,
    publicKey,
    secretKey,
    createAccount,
    signIn,
    signOut,
  };
};
```

### Creating and Managing Stellar Accounts

Now that we have our `useStellar` hook, let's create a component to handle account creation and sign-in. Create a new file `src/components/AccountManager.tsx`:

```typescript
import React, { useState } from 'react';
import { useStellar } from '../hooks/useStellar';
import Button from './Button';
import Input from './Input';

const AccountManager: React.FC = () => {
  const { publicKey, secretKey, createAccount, signIn, signOut } = useStellar();
  const [inputSecretKey, setInputSecretKey] = useState('');

  const handleSignIn = () => {
    if (inputSecretKey) {
      signIn(inputSecretKey);
    }
  };

  if (publicKey && secretKey) {
    return (
```
